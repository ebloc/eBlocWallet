{
  "author": {
    "name": "Ben Newman",
    "email": "bn@cs.stanford.edu"
  },
  "name": "install",
  "description": "Minimal JavaScript module loader",
  "keywords": [
    "modules",
    "require",
    "commonjs",
    "exports",
    "browser",
    "packaging",
    "packager",
    "install"
  ],
  "version": "0.8.4",
  "license": "MIT",
  "homepage": "http://github.com/benjamn/install",
  "repository": {
    "type": "git",
    "url": "git://github.com/benjamn/install.git"
  },
  "main": "install.js",
  "scripts": {
    "prepublish": "scripts/prepublish.sh",
    "docs": "scripts/docs.sh",
    "test": "mocha --reporter spec --full-trace test/run.js"
  },
  "devDependencies": {
    "docco": "^0.7.0",
    "mocha": "^2.3.3",
    "uglifyjs": "^2.4.10",
    "reify": "^0.1.9"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "readme": "# install [![Build Status](https://travis-ci.org/benjamn/install.svg?branch=master)](https://travis-ci.org/benjamn/install)\n\nThe [CommonJS module syntax](http://wiki.commonjs.org/wiki/Modules/1.1) is one of the most widely accepted conventions in the JavaScript ecosystem. Everyone seems to agree that `require` and `exports` are a reasonable way of expressing module dependencies and interfaces, and the tools for managing modular code are getting better all the time.\n\nMuch less of a consensus has developed around the best way to deliver CommonJS modules to a web browser, where the synchronous semantics of `require` pose a non-trivial implementation challenge. This module loader contributes to that confusion, yet also demonstrates that an amply-featured module loader need not stretch into the hundreds or thousands of lines.\n\nInstallation\n---\nFrom NPM:\n\n    npm install install\n\nFrom GitHub:\n\n    cd path/to/node_modules\n    git clone git://github.com/benjamn/install.git\n    cd install\n    npm install .\n\nUsage\n---\n\nThe first step is to create an `install` function by calling the\n`makeInstaller` method. Note that all of the options described below are\noptional:\n\n```js\nvar install = require(\"install\").makeInstaller({\n  // Optional list of file extensions to be appended to required module\n  // identifiers if they do not exactly match an installed module.\n  extensions: [\".js\", \".json\"],\n\n  // If defined, the options.onInstall function will be called any time\n  // new modules are installed.\n  onInstall,\n\n  // If defined, the options.override function will be called before\n  // looking up any top-level package identifiers in node_modules\n  // directories. It can return either a string to provide an alternate\n  // package identifier or a non-string value to prevent the lookup from\n  // proceeding.\n  override,\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  fallback\n});\n```\n\nThe second step is to install some modules by passing a nested tree of\nobjects and functions to the `install` function:\n\n```js\nvar require = install({\n  \"main.js\": function (require, exports, module) {\n    // On the client, the \"assert\" module should be install-ed just like\n    // any other module. On the server, since \"assert\" is a built-in Node\n    // module, it may make sense to let the options.fallback function\n    // handle such requirements. Both ways work equally well.\n    var assert = require(\"assert\");\n\n    assert.strictEqual(\n      // This require function uses the same lookup rules as Node, so it\n      // will find \"package\" in the \"node_modules\" directory below.\n      require(\"package\").name,\n      \"/node_modules/package/entry.js\"\n    );\n\n    exports.name = module.id;\n  },\n\n  node_modules: {\n    package: {\n      // If package.json is not defined, a module called \"index.js\" will\n      // be used as the main entry point for the package. Otherwise the\n      // exports.main property will identify the entry point.\n      \"package.json\": function (require, exports, module) {\n        exports.name = \"package\";\n        exports.version = \"0.1.0\";\n        exports.main = \"entry.js\";\n      },\n\n      \"entry.js\": function (require, exports, module) {\n        exports.name = module.id;\n      }\n    }\n  }\n});\n```\n\nNote that the `install` function merely installs modules without\nevaluating them, so the third and final step is to `require` any entry\npoint modules that you wish to evaluate:\n\n```js\nconsole.log(require(\"./main\").name);\n// => \"/main.js\"\n```\n\nThis is the \"root\" `require` function returned by the `install`\nfunction. If you're using the `install` package in a CommonJS environment\nlike Node, be careful that you don't overwrite the `require` function\nprovided by that system.\n\nMany more examples of how to use the `install` package can be found in the\n[tests](https://github.com/benjamn/install/blob/master/test/run.js).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/benjamn/install/issues"
  },
  "_id": "install@0.8.4",
  "_from": "install@^0.8.4"
}
